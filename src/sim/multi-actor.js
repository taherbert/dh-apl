// Generates multi-actor .simc content from a build roster + APL file.
// Each build in the roster becomes a separate actor sharing the same APL and gear.
// First actor gets full profile; subsequent actors use copy= with talent overrides.
//
// Usage: node src/sim/multi-actor.js [apl-path] [roster-path]

import { readFileSync, existsSync } from "node:fs";
import { join, dirname, resolve } from "node:path";
import { fileURLToPath } from "node:url";
import { resolveInputDirectives } from "./profilesets.js";
import { DATA_ENV } from "../config.js";

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = join(__dirname, "..", "..");
const PROFILE_PATH = join(ROOT, "apls", "profile.simc");

// Lines from profile.simc that define the character (not gear, not talents)
const CHAR_META_KEYS = [
  "spec",
  "level",
  "race",
  "timeofday",
  "role",
  "position",
];

// Lines that are gear slots
const GEAR_KEYS = [
  "head",
  "neck",
  "shoulder",
  "back",
  "chest",
  "wrist",
  "hands",
  "waist",
  "legs",
  "feet",
  "finger1",
  "finger2",
  "trinket1",
  "trinket2",
  "main_hand",
  "off_hand",
];

// Generate multi-actor .simc content from roster + APL.
// roster: { builds: [{ id, heroTree, hash?, overrides? }] }
// aplPath: path to APL .simc file
export function generateMultiActorContent(roster, aplPath) {
  const profileContent = readFileSync(PROFILE_PATH, "utf8");
  const profileLines = profileContent.split("\n");

  // Extract character metadata and gear from profile
  const charMeta = {};
  const gearLines = [];
  const otherProfileLines = [];

  for (const line of profileLines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) continue;

    const eqIdx = trimmed.indexOf("=");
    if (eqIdx === -1) continue;
    const key = trimmed.slice(0, eqIdx).trim();

    if (CHAR_META_KEYS.includes(key)) {
      charMeta[key] = trimmed;
    } else if (GEAR_KEYS.includes(key)) {
      gearLines.push(trimmed);
    } else if (
      key !== "demonhunter" &&
      key !== "source" &&
      key !== "talents" &&
      key !== "ptr" &&
      key !== "input"
    ) {
      otherProfileLines.push(trimmed);
    }
  }

  // Read and resolve APL file, extract only action lines
  const rawApl = readFileSync(resolve(aplPath), "utf8");
  const resolvedApl = resolveInputDirectives(rawApl, dirname(resolve(aplPath)));
  const actionLines = resolvedApl
    .split("\n")
    .filter((l) => l.trim().startsWith("actions"));

  if (actionLines.length === 0) {
    throw new Error(`No action lines found in ${aplPath}`);
  }

  const builds = roster.builds;
  if (builds.length === 0) {
    throw new Error("Roster has no builds");
  }

  const output = [];

  // Header
  output.push("# Multi-actor comparison (auto-generated by multi-actor.js)");
  output.push(`# Roster: ${builds.length} builds, tier: ${roster.tier}`);
  output.push("");

  // PTR flag
  if (DATA_ENV === "ptr" || DATA_ENV === "beta") {
    output.push("ptr=1");
    output.push("");
  }

  // First actor — full profile
  const first = builds[0];
  output.push(`demonhunter="${first.id}"`);
  output.push("source=default");
  for (const key of CHAR_META_KEYS) {
    if (charMeta[key]) output.push(charMeta[key]);
  }

  // Talent overrides for first actor
  if (first.hash) {
    output.push(`talents=${first.hash}`);
  }
  if (first.overrides) {
    if (first.overrides.class_talents)
      output.push(`class_talents=${first.overrides.class_talents}`);
    if (first.overrides.spec_talents)
      output.push(`spec_talents=${first.overrides.spec_talents}`);
    if (first.overrides.hero_talents)
      output.push(`hero_talents=${first.overrides.hero_talents}`);
  }

  // Gear + consumables
  for (const line of otherProfileLines) {
    output.push(line);
  }
  for (const line of gearLines) {
    output.push(line);
  }

  output.push("");

  // Inline APL (not via input= to avoid creating extra actor)
  for (const line of actionLines) {
    output.push(line);
  }

  output.push("");

  // Subsequent actors — copy from first
  for (let i = 1; i < builds.length; i++) {
    const build = builds[i];
    output.push(`copy="${build.id}","${first.id}"`);

    if (build.hash) {
      output.push(`talents=${build.hash}`);
    }
    if (build.overrides) {
      if (build.overrides.class_talents)
        output.push(`class_talents=${build.overrides.class_talents}`);
      if (build.overrides.spec_talents)
        output.push(`spec_talents=${build.overrides.spec_talents}`);
      if (build.overrides.hero_talents)
        output.push(`hero_talents=${build.overrides.hero_talents}`);
    }

    output.push("");
  }

  return output.join("\n");
}

// CLI entry point
if (import.meta.url === `file://${process.argv[1]}`) {
  const aplPath = process.argv[2] || join(ROOT, "apls", "vengeance.simc");
  const rosterPath =
    process.argv[3] || join(ROOT, "results", "build-roster.json");

  if (!existsSync(rosterPath)) {
    console.error(
      `Roster not found: ${rosterPath}\nRun: node src/sim/build-roster.js generate`,
    );
    process.exit(1);
  }

  const roster = JSON.parse(readFileSync(rosterPath, "utf8"));
  const content = generateMultiActorContent(roster, aplPath);

  console.log(content);
  console.error(`\nGenerated ${roster.builds.length}-actor SimC content`);
}
