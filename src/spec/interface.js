// Spec adapter contract — documents what a spec adapter must export.
// This file is not imported directly. It exists as documentation and
// for runtime validation of adapter conformance.
//
// To add a new spec:
// 1. Create src/spec/{specname}.js exporting these symbols
// 2. Create config.{specname}.json with spec identity (className, specName, specId)
// 3. Run `SPEC={specname} npm run build-data` to generate data for the new spec
// 4. Run `SPEC={specname} node src/spec/validate-spec-data.js` to verify constants
//
// Spec file structure — three sections:
//
//   // ================================================================
//   // SECTION 1: HUMAN DOMAIN KNOWLEDGE
//   // Edit when game mechanics, abilities, or set bonuses change.
//   // ================================================================
//
//   export const SPEC_CONFIG = { ... };      // identity, resources, spellIds, etc.
//   export const SET_BONUS_SPELL_IDS = ...;   // tier set spell IDs
//   export const STRUCT_TO_ABILITY_MAP = ...; // C++ struct → display name
//   export const CPP_SCANNER_SEEDS = ...;    // validation fixture
//
//   // ================================================================
//   // SECTION 2: MACHINE-VALIDATED DATA
//   // Sourced from SimC DBC, cross-checked by validate-spec-data.js.
//   // ================================================================
//
//   export const BASE_SPELL_IDS = ...;       // spec baseline abilities
//
//   // ================================================================
//   // SECTION 3: AUTO-DERIVED (do not edit)
//   // Generated by common.js from SPEC_CONFIG.
//   // ================================================================
//
//   // Derivable functions delegate to common.js:
//   // getClassSpellQuery(), getCppStructPatterns(), getSpecSpellFilter(),
//   // getTalentTreePattern(), getKeySpellIds()
//
// SPEC_CONFIG required fields:
//   - specId, className, cppClassName, role
//   - displayNames: { class, spec }
//   - resources: { primary: {name, cap}, secondary?: {name, cap} }
//   - spellIds, domainOverrides, resourceFlow
//   - heroTrees: { [key]: { displayName, subtree, buildMethod, damageSchool, keyBuffs, aplBranch, profileKeywords, choiceLocks? } }
//       buildMethod: "doe" (DoE discovery pipeline) or "multi-actor" (manual .simc file)
//       choiceLocks: { [nodeId]: entryIndex } — DPS-optimal hero choice locks (determined by sim)
//   - buffWindows, synergies
//   - keyBuffs, offGcdAbilities, cooldownBuffs
//   - classificationHints, resourceNames
//
// SPEC_CONFIG optional fields (for build generation):
//   - excludedTalents: string[] — Non-DPS talent names excluded from DoE factor space.
//     Pure defensive, utility, or healing-only talents. Connectivity repair may still
//     add them as pathing nodes to reach deeper DPS talents.
//   - requiredTalents: string[] — Talent names forced always-on in DoE factor space.
//     Use for talents that must be taken (e.g., SimC crashes without them, or they are
//     fundamental to the spec's core loop and never worth dropping).
//
// SPEC_CONFIG optional fields (for analysis/simulation):
//   - fillerAbilities: string[] — lowest-priority GCD-fill abilities (for divergence noise filtering)
//   - cooldownDurations: { [ability]: seconds | (cfg) => seconds } — base CD durations for apl-interpreter
//   - chargeAbilities: { [ability]: { maxCharges, rechargeCd } } — charge tracking in apl-interpreter
//
// SPEC_CONFIG optional fields (for data-driven analysis modules):
//   - resourceModels: Array of { name, cap, baseCap?, generators[], consumers[] }
//     Detailed resource generation/consumption models used by theorycraft and
//     hypothesis generators. Extends the simpler resourceFlow with charge data,
//     meta bonuses, proc rates, and value-per-unit descriptions.
//   - burstWindows: Array of { buff, cooldown, duration, damageAmp, school,
//     talentDep?, syncTargets?, resourceBonus? }
//     Damage amplification windows with sync targets for cooldown alignment
//     hypotheses.
//   - stateMachines: Object keyed by hero tree name. Each entry describes a
//     repeating ability cycle with states, transitions, and uptime targets.
//     Used by hypothesis generators to check cycle completion.
//   - hypothesisPatterns: Array of { id, category, template, appliesWhen(config) }
//     Parameterized hypothesis templates. Each has a predicate that checks the
//     spec config to determine applicability. Analysis modules iterate these
//     to generate spec-specific optimization hypotheses.
//   - clusterKeywords: Object mapping cluster names to keyword arrays. Used by
//     interaction clustering to group talents/spells by thematic similarity.
//   - schoolClusters: Object mapping damage school names to cluster identifiers.
//     Used by damage school analysis to group abilities.
//
// Resource caps should be BASE values (without talents). Use validate-spec-data.js
// to catch values that accidentally include talent bonuses.

/**
 * @typedef {Object} SpecAdapter
 *
 * Required exports from a spec adapter module:
 *
 * @property {Set<number>} BASE_SPELL_IDS
 *   Spell IDs granted by the spec (not talents). Used by extraction to seed
 *   the spell catalog. These are find_specialization_spell() calls in simc C++.
 *
 * @property {Set<number>} SET_BONUS_SPELL_IDS
 *   Spell IDs from tier set bonuses. Separate from base abilities since they
 *   come from gear. Included in spell extraction.
 *
 * @property {Object} SPEC_CONFIG
 *   Static spec configuration. See SPEC_CONFIG required fields above.
 *
 * @property {function(): Object} getSpecConfig
 *   Returns SPEC_CONFIG.
 *
 * @property {function(): Object} loadAbilityData
 *   Merges spell data from spells-summary.json with domain overrides.
 *   Returns frozen object keyed by ability name.
 *
 * @property {function(): Object} getHeroTrees
 *   Returns hero tree configs from SPEC_CONFIG.
 *   Each tree must have: displayName, subtree, damageSchool, keyBuffs, aplBranch, profileKeywords.
 *   displayName must match the Raidbots talent tree display name exactly.
 *
 * @property {function(): Object} getResourceFlow
 *   Returns resource flow config from SPEC_CONFIG.
 *
 * @property {function(string): string|null} detectHeroTreeFromProfileName
 *   Given APL text, detects which hero tree is active from profile keywords.
 *
 * @property {function(Object): string|null} detectHeroTreeFromBuffs
 *   Given workflow results, detects hero tree from buff uptimes.
 *
 * @property {function(): Record<string, number>} getSpellIds
 *   Returns spell ID map from SPEC_CONFIG.
 *
 * @property {function(): Record<string, Object>} getDomainOverrides
 *   Returns domain override map from SPEC_CONFIG.
 *
 * @property {function(): void} clearCache
 *   Clears any cached ability data (for testing/reloads).
 *
 * @property {function(): Record<string,string>} getStructToAbilityMap
 *   Maps C++ struct names to display ability names. Used by cpp-interactions.js
 *   to resolve struct contexts to human-readable ability names.
 *
 * @property {function(): RegExp} getTalentTreePattern
 *   Returns regex matching C++ talent references for this class.
 *
 * @property {function(): Map<number, Object>} getSetBonusSpells
 *   Returns tier set bonus spell IDs with metadata (name, pieceCount, displayName).
 *
 * @property {function(): string} getClassSpellQuery
 *   Returns the simc spell_query class filter string.
 *
 * @property {function(Object): boolean} getSpecSpellFilter
 *   Returns a predicate to filter modifier spells to this spec.
 *
 * @property {function(): Object} getCppStructPatterns
 *   Returns C++ struct name patterns for this class.
 *
 * @property {function(): Array} getKeySpellIds
 *   Returns [[id, displayName], ...] pairs for key spec abilities.
 *
 * @property {function(): Object} getSiblingSpecs
 *   Returns { siblingSpec, siblingHeroTrees } for contamination detection.
 */

const REQUIRED_EXPORTS = [
  "BASE_SPELL_IDS",
  "SET_BONUS_SPELL_IDS",
  "SPEC_CONFIG",
  "getSpecConfig",
  "loadAbilityData",
  "getHeroTrees",
  "getResourceFlow",
  "detectHeroTreeFromProfileName",
  "detectHeroTreeFromBuffs",
  "getSpellIds",
  "getDomainOverrides",
  "clearCache",
  "getStructToAbilityMap",
  "getTalentTreePattern",
  "getSetBonusSpells",
  "getClassSpellQuery",
  "getSpecSpellFilter",
  "getCppStructPatterns",
  "getKeySpellIds",
  "getSiblingSpecs",
];

/**
 * Validates that a loaded module conforms to the spec adapter contract.
 * @param {Object} mod — The imported module
 * @param {string} specName — For error messages
 * @returns {{ valid: boolean, missing: string[] }}
 */
export function validateAdapter(mod, specName) {
  const missing = REQUIRED_EXPORTS.filter((name) => !(name in mod));
  return {
    valid: missing.length === 0,
    missing,
  };
}

export { REQUIRED_EXPORTS };
