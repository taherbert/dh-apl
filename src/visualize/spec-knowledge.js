// Generates reference/{spec}-knowledge.md from SPEC_CONFIG and APL structure.
// Pre-computes stable structural knowledge so /optimize subagents can read it
// directly instead of exploring the codebase each session.

import { readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import { initSpec, getSpecAdapter } from "../engine/startup.js";
import { parseSpecArg } from "../util/parse-spec-arg.js";
import { aplsDir, REFERENCE_DIR, getSpecName } from "../engine/paths.js";
import { parse, getActionLists } from "../apl/parser.js";

function truncate(s, max = 80) {
  return s.length > max ? s.slice(0, max - 3) + "..." : s;
}

function generate() {
  const spec = getSpecName();
  const cfg = getSpecAdapter().getSpecConfig();
  const sections = [];

  sections.push(`# ${cfg.displayNames.spec} ${cfg.displayNames.class} - Spec Knowledge`);
  sections.push(`> Auto-generated by \`npm run spec-knowledge\`. Do not edit manually.`);

  sections.push(resourceSection(cfg));
  sections.push(abilitiesSection(cfg));
  sections.push(heroTreesSection(cfg));
  sections.push(apexSection(cfg));
  sections.push(clustersSection(cfg));
  sections.push(burstWindowsSection(cfg));
  sections.push(aplSection(spec));
  sections.push(rosterSection(cfg));
  sections.push(constraintsSection(cfg));

  const md = sections.filter(Boolean).join("\n\n") + "\n";
  const outPath = join(REFERENCE_DIR, `${spec}-knowledge.md`);
  writeFileSync(outPath, md);

  const sizeKB = (Buffer.byteLength(md) / 1024).toFixed(1);
  console.log(`Wrote ${outPath} (${sizeKB}KB)`);
}

function resourceSection(cfg) {
  const lines = ["## Resource System"];
  const { resources, resourceModels } = cfg;

  if (resources?.primary) {
    lines.push(`- **Primary:** ${resources.primary.name} (cap: ${resources.primary.cap})`);
  }
  if (resources?.secondary) {
    lines.push(`- **Secondary:** ${resources.secondary.name} (cap: ${resources.secondary.cap})`);
  }

  if (resourceModels) {
    for (const rm of resourceModels) {
      lines.push("");
      lines.push(`### ${rm.name}`);
      if (rm.cap) lines.push(`- Cap: ${rm.cap}${rm.baseCap ? ` (base: ${rm.baseCap})` : ""}`);

      if (rm.generators?.length) {
        lines.push("- **Generators:**");
        for (const g of rm.generators) {
          const parts = [`  - ${g.ability}`];
          if (g.amount != null) parts.push(`${g.amount}`);
          if (g.metaAmount != null) parts.push(`(${g.metaAmount} in Meta)`);
          if (g.perTick != null && typeof g.perTick === "number") parts.push(`${g.perTick}/tick`);
          if (g.duration != null) parts.push(`over ${g.duration}s`);
          if (g.cooldown != null && g.cooldown > 0) parts.push(`CD: ${g.cooldown}s`);
          if (g.charges) parts.push(`${g.charges} charges`);
          if (g.rechargeCd) parts.push(`recharge: ${g.rechargeCd}s`);
          if (g.passive) parts.push("(passive)");
          if (g.procRate) parts.push(`proc: ${g.procRate}`);
          if (g.interval) parts.push(`every ${g.interval}s`);
          lines.push(parts.join(" "));
        }
      }

      if (rm.consumers?.length) {
        lines.push("- **Consumers:**");
        for (const c of rm.consumers) {
          const parts = [`  - ${c.ability}`];
          if (c.cost != null) parts.push(`cost: ${c.cost}`);
          if (c.maxConsume != null) parts.push(`consumes up to ${c.maxConsume}`);
          if (c.consume != null) parts.push(`consumes: ${c.consume}`);
          if (c.minRequired != null) parts.push(`min: ${c.minRequired}`);
          if (c.valuePerUnit) parts.push(`(${c.valuePerUnit})`);
          if (c.channel) parts.push("(channel)");
          lines.push(parts.join(" "));
        }
      }

      if (rm.drain?.active) {
        lines.push(`- **Drain:** ${rm.drain.active}, base ${rm.drain.baseRate ?? "?"}/sec`);
      }
    }
  }

  return lines.join("\n");
}

function abilitiesSection(cfg) {
  const lines = ["## Core Abilities"];
  const { spellIds, domainOverrides } = cfg;
  if (!spellIds) return null;

  lines.push("");
  lines.push("| Ability | Spell ID | Key Properties |");
  lines.push("|---------|----------|----------------|");

  for (const [name, id] of Object.entries(spellIds)) {
    if (id === 0) continue;
    const overrides = domainOverrides?.[name] || {};
    const props = [];
    if (overrides.school) props.push(overrides.school);
    if (overrides.aoeTargets) props.push(`${overrides.aoeTargets}T AoE`);
    if (overrides.channel) props.push("channel");
    if (overrides.gcd === false) props.push("off-GCD");
    if (overrides.charges) props.push(`${overrides.charges} charges`);
    if (overrides.furyGen != null) props.push(`gen ${overrides.furyGen} fury`);
    if (overrides.furyRefundChance) props.push(`${(overrides.furyRefundChance * 100).toFixed(0)}% refund`);
    if (overrides.fragConsume) props.push(`consumes ${overrides.fragConsume} frags`);
    if (overrides.duration) props.push(`${overrides.duration}s`);
    if (overrides.damageAmp) props.push(`+${(overrides.damageAmp * 100).toFixed(0)}% amp`);
    lines.push(`| ${name} | ${id} | ${props.join(", ") || "-"} |`);
  }

  return lines.join("\n");
}

function heroTreesSection(cfg) {
  const lines = ["## Hero Trees"];
  const { heroTrees, stateMachines } = cfg;
  if (!heroTrees) return null;

  for (const [key, tree] of Object.entries(heroTrees)) {
    lines.push("");
    lines.push(`### ${tree.displayName} (\`hero_tree.${key}\`)`);
    lines.push(`- APL branch: \`${tree.aplBranch}\``);
    lines.push(`- Damage school: ${tree.damageSchool}`);
    lines.push(`- Key buffs: ${tree.keyBuffs.map((b) => `\`${b}\``).join(", ")}`);

    if (tree.choiceLocks) {
      const locks = Object.entries(tree.choiceLocks);
      if (locks.length) {
        lines.push(`- Choice locks: ${locks.map(([id, v]) => `${id}=${v}`).join(", ")}`);
      }
    }

    const sm = stateMachines?.[key];
    if (sm) {
      lines.push(`- **Cycle:** ${sm.name} - ${sm.description}`);
      if (sm.states?.length) {
        const stateNames = sm.states.map((s) => s.name).join(" -> ");
        lines.push(`  - States: ${stateNames}`);
      }
      if (sm.uptimeTargets && Object.keys(sm.uptimeTargets).length) {
        const targets = Object.entries(sm.uptimeTargets)
          .map(([b, pct]) => `${b}: ${pct}%`)
          .join(", ");
        lines.push(`  - Uptime targets: ${targets}`);
      }
    }
  }

  return lines.join("\n");
}

function apexSection(cfg) {
  const { rosterTemplates } = cfg;
  if (!rosterTemplates?.length) return null;

  const ranks = new Set(rosterTemplates.map((t) => t.apexRank));
  const min = Math.min(...ranks);
  const max = Math.max(...ranks);

  const lines = ["## Apex Talents"];
  lines.push(`- Rank range: ${min}-${max}`);
  lines.push(`- SimC syntax: \`apex.N\` (e.g., \`apex.1\`, \`apex.3\`)`);
  lines.push(`- Do NOT use \`talent.apex_name\` - always use \`apex.N\``);
  return lines.join("\n");
}

function clustersSection(cfg) {
  const { talentClusters } = cfg;
  if (!talentClusters) return null;

  const lines = ["## Talent Clusters"];
  for (const [name, cluster] of Object.entries(talentClusters)) {
    const core = cluster.core?.join(", ") || "-";
    const ext = cluster.extended?.join(", ");
    const extStr = ext ? ` | Extended: ${ext}` : "";
    lines.push(`- **${name}:** Core: ${core}${extStr}`);
  }
  return lines.join("\n");
}

function burstWindowsSection(cfg) {
  const { burstWindows } = cfg;
  if (!burstWindows?.length) return null;

  const lines = ["## Burst Windows"];
  for (const w of burstWindows) {
    const parts = [`- **${w.buff}**`];
    if (w.cooldown) parts.push(`CD: ${w.cooldown}s`);
    if (w.duration) parts.push(`dur: ${w.duration}s`);
    if (w.damageAmp) parts.push(`+${(w.damageAmp * 100).toFixed(0)}% ${w.school}`);
    if (w.syncTargets?.length) parts.push(`sync: ${w.syncTargets.join(", ")}`);
    if (w.talentDep) parts.push(`(requires ${w.talentDep})`);
    lines.push(parts.join(", "));
    if (w.resourceBonus?.description) {
      lines.push(`  - Resource bonus: ${w.resourceBonus.description}`);
    } else if (w.resourceBonus?.bonus != null) {
      lines.push(`  - Resource bonus: +${w.resourceBonus.bonus} ${w.resourceBonus.resource} from ${w.resourceBonus.ability}`);
    }
  }
  return lines.join("\n");
}

function aplSection(spec) {
  const aplPath = join(aplsDir(), `${spec}.simc`);
  let text;
  try {
    text = readFileSync(aplPath, "utf-8");
  } catch {
    return null;
  }

  const sections = parse(text);
  const lists = getActionLists(sections);

  const lines = ["## APL Structure"];
  lines.push(`- File: \`apls/${spec}/${spec}.simc\``);
  lines.push(`- Action lists: ${lists.length}`);
  lines.push("");

  // Action list overview + capture default delegations
  let defaultDelegations = null;
  lines.push("### Action Lists");
  for (const list of lists) {
    const actions = list.entries.filter((e) => e.type !== "Comment");
    const delegations = actions.filter((e) => e.type === "RunActionList");
    const desc = [];
    desc.push(`${actions.length} actions`);
    if (delegations.length) {
      const targets = delegations.map((d) => {
        const name = d.modifiers.get("name");
        return `${d.variant}_action_list -> ${name}`;
      });
      desc.push(`delegates: ${targets.join(", ")}`);
    }
    lines.push(`- **${list.name}:** ${desc.join("; ")}`);
    if (list.name === "default" && delegations.length) {
      defaultDelegations = delegations;
    }
  }

  // Variables (deduplicate by name)
  const seenVars = new Set();
  const variables = [];
  for (const list of lists) {
    for (const entry of list.entries) {
      if (entry.type !== "Variable") continue;
      const name = entry.modifiers.get("name");
      if (!name || seenVars.has(name)) continue;
      seenVars.add(name);
      const raw = entry.modifiers.get("value") || entry.modifiers.get("default") || "";
      variables.push({ name, value: truncate(raw), list: list.name });
    }
  }

  if (variables.length) {
    lines.push("");
    lines.push("### APL Variables");
    for (const v of variables) {
      lines.push(`- **${v.name}** (${v.list}): \`${v.value}\``);
    }
  }

  // Delegation pattern (from captured default list delegations)
  if (defaultDelegations) {
    lines.push("");
    lines.push("### Delegation Pattern");
    for (const d of defaultDelegations) {
      const name = d.modifiers.get("name");
      const cond = d.modifiers.get("if") || "(unconditional)";
      lines.push(`- \`${d.variant}_action_list -> ${name}\`: \`${truncate(cond)}\``);
    }
  }

  return lines.join("\n");
}

function rosterSection(cfg) {
  const { rosterTemplates, heroTrees } = cfg;
  if (!rosterTemplates?.length) return null;

  const treeNames = Object.values(heroTrees || {}).map((t) => t.displayName);
  const ranks = [...new Set(rosterTemplates.map((t) => t.apexRank))].sort((a, b) => a - b);
  const perRank = {};
  for (const t of rosterTemplates) {
    perRank[t.apexRank] = (perRank[t.apexRank] || 0) + 1;
  }

  const lines = ["## Roster Overview"];
  lines.push(`- Templates: ${rosterTemplates.length}`);
  lines.push(`- Hero trees: ${treeNames.join(", ")}`);
  lines.push(`- Apex range: ${ranks[0]}-${ranks[ranks.length - 1]}`);
  lines.push(`- Per rank: ${ranks.map((r) => `Apex ${r}: ${perRank[r]}`).join(", ")}`);

  const axes = [];
  if (treeNames.length > 1) axes.push("hero tree");
  if (ranks.length > 1) axes.push("apex rank");
  const hasVariants = rosterTemplates.some((t) => t.require || t.exclude);
  if (hasVariants) axes.push("talent variant (require/exclude)");
  if (axes.length) {
    lines.push(`- Variation axes: ${axes.join(", ")}`);
  }

  return lines.join("\n");
}

function constraintsSection(cfg) {
  const { heroTrees } = cfg;
  const lines = ["## Design Constraints"];

  lines.push("- **Shared APL:** All builds share one APL file. Hero tree routing via `run_action_list` with `hero_tree.<name>` conditions.");
  lines.push("- **Gating pattern:** When a change helps some builds but hurts others, gate with the discriminating SimC expression (hero tree, apex rank, talent presence).");
  lines.push("- **Significance:** Quick fidelity (te=0.5) noise floor: +/-0.5%. Standard (te=0.25): +/-0.25%. Confirm (te=0.1): +/-0.1%.");
  lines.push("- **APL comments:** Plain ASCII only, no consecutive comment lines, no em dashes or decorative characters.");

  if (heroTrees) {
    const branches = Object.entries(heroTrees).map(
      ([key, t]) => `\`${t.aplBranch}\` (${t.displayName})`
    );
    lines.push(`- **Hero branches:** ${branches.join(", ")}`);
  }

  return lines.join("\n");
}

await initSpec(parseSpecArg());
generate();
