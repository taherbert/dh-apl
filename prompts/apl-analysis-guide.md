# APL Analysis Methodology Reference — Vengeance Demon Hunter

Load this document at the start of any APL analysis session. It provides calculation frameworks, data field references, and worked examples for Vengeance Demon Hunter SimulationCraft APL optimization.

All field paths reference the project data files: `data/spells.json`, `data/interactions.json`, `data/talents.json`.

---

## 1. Resource Flow Analysis

### Fury Economy

Fury is a builder/spender resource capped at 120 (base). Generation and spending must be modeled to avoid overcapping (waste) or starvation (empty GCDs).

**Generation sources** (from `resourceFlow.generates[]` and `effects[].details.Resource`):

- Fracture (263642): 25 Fury per cast (`effects[3].details.baseValue: 25`, type: Energize Power). 2 charges, 4.5s recharge (`charges: {count: 2, cooldown: 4.5}`).
- Shear (203782): 10 Fury per cast (`resourceFlow.generates[0].amount: 10`).
- Immolation Aura: passive Fury generation over duration.
- Felblade: Fury on hit (from triggered spell).
- Metamorphosis: bonus Fury per Fracture/Shear during uptime.

**Spending priorities** (from `resource.cost` or `resourceFlow.costs[]`):

- Spirit Bomb (247454): 40 Fury (`resourceFlow.costs[0].amount: 40`).
- Soul Cleave (228477): 30 Fury (`resource.cost: 30`).
- Fel Devastation: 50 Fury channel.

**Fury equilibrium equation:**

```
FuryPerSecond_gen = (Fracture_casts/sec * 25) + (ImmoAura_fury/sec) + (Felblade_fury / Felblade_cd)
FuryPerSecond_spend = (SpenderCasts/sec * spender_cost)
Equilibrium when: FuryPerSecond_gen >= FuryPerSecond_spend
```

To compute Fracture casts per second: with 2 charges and 4.5s recharge (haste-scaled), sustained rate = 1 / (4.5 / haste_factor). At 20% haste: 1 / (4.5 / 1.2) = 0.267 casts/sec = 6.67 Fury/sec from Fracture alone.

**Overcap risk:** If Fury generation exceeds spending capacity, excess Fury is wasted. Model waste as:

```
waste_per_sec = max(0, FuryPerSecond_gen - FuryPerSecond_spend)
waste_dps_cost = waste_per_sec * (best_spender_damage / best_spender_cost)
```

### Soul Fragment Economy

Soul Fragments are generated by specific abilities and consumed by Spirit Bomb (up to 5) or Soul Cleave (up to 2).

**Generation** (from spell descriptions and `effects[].details.baseValue`):

- Fracture: 2 Lesser Soul Fragments per cast (from `effects[0].details.baseValue: 2` on spell 263642).
- Soul Carver: 3 fragments over duration.
- Fallout (talent): chance to generate fragments from Immolation Aura ticks (AoE-dependent).
- Metamorphosis: +1 fragment per Fracture/Shear.

**Consumption:**

- Spirit Bomb: consumes up to 5 (`effects[1].details.baseValue: 5` on spell 247454).
- Soul Cleave: consumes up to 2 (`effects[2].details.baseValue: 2` on spell 228477).

**Fragment equilibrium:**

```
fragments_per_cycle = fracture_casts * 2 + soul_carver_frags + fallout_procs
fragments_consumed_per_cycle = spirit_bomb_casts * avg_fragments_consumed
```

Spirit Bomb is optimal when consuming 4-5 fragments. Below 4, Soul Cleave may be more Fury-efficient.

**Fragment type discrimination:** SimC tracks Greater and Lesser soul fragments separately. APL conditions can use `soul_fragments` (all active consumable), `greater_soul_fragments`, `lesser_soul_fragments`, or `demon_soul_fragments`. Each supports `.active`, `.inactive`, and `.total` filters (e.g., `soul_fragments.inactive` for spawned-but-not-yet-consumable fragments). See `reference/wiki/demon-hunters.md` for the full list.

### GCD Budget Modeling

At 1.5s base GCD (haste-scaled), the total GCD budget per minute is:

```
GCDs_per_minute = 60 / (1.5 / haste_factor)
```

At 20% haste: 60 / 1.25 = 48 GCDs/min.

**On-GCD abilities compete for time.** Check `gcd` field in spells.json:

- `gcd: 1.5` = on-GCD (Fracture, Spirit Bomb, Soul Cleave, Sigil of Flame, etc.)
- `gcd: 0` = off-GCD (Demon Spikes, Metamorphosis, Infernal Strike, Vengeful Retreat)
- `gcd: 0.5` = reduced GCD (Felblade)

GCD allocation framework:

```
GCDs_available = 48  (at 20% haste)
GCDs_fracture  = min(charges_available, fury_needed / 25) * ...
GCDs_spender   = fragments_available / fragments_per_spender
GCDs_sigil     = 1 per cooldown cycle
GCDs_filler    = GCDs_available - (fracture + spender + sigil + ...)
```

If allocated GCDs exceed budget, lower-priority abilities get dropped. This is the core APL ordering problem.

---

## 2. Damage-per-GCD Framework

### Raw DPGCD from AP Coefficients

Look up `effects[].details.apCoefficient` in spells.json. This is the fraction of Attack Power dealt as damage per hit.

```
raw_damage = AP * apCoefficient * (1 + delta/2)  [average with delta variance]
DPGCD = raw_damage / (gcd_duration)
```

**Key AP coefficients:**

- Fracture (225919): `apCoefficient: 0.627` (main hand) + Fracture (225921) off-hand hit
- Spirit Bomb damage (247455): `apCoefficient: 0.365` per fragment consumed
- Soul Cleave: via triggered spell 228478
- Fiery Brand (204021): `apCoefficient: 2.08` (initial hit)
- Sigil of Flame (204598): check DoT coefficient

For Spirit Bomb, total coefficient scales with fragments:

```
SpiritBomb_coefficient = 0.365 * num_fragments
SpiritBomb_5frag = 0.365 * 5 = 1.825 total AP coefficient
```

### Effective DPGCD with Modifier Stacking

Look up interactions targeting the spell in `interactions.json`. Filter by `type: "damage_modifier"`.

Modifiers with `magnitude.stacking: "multiplicative"` multiply together:

```
effective_damage = raw_damage * (1 + mod1) * (1 + mod2) * ...
```

Modifiers with `magnitude.stacking: "additive"` sum before applying:

```
effective_damage = raw_damage * (1 + mod1 + mod2 + ...)
```

Example — Fiery Demise on Spirit Bomb:

- Source: Fiery Demise (212818), target: Spirit Bomb (247455)
- `magnitude: {value: 15, unit: "percent", perRank: true, maxRank: 2, stacking: "multiplicative"}`
- At 2/2: 30% multiplicative damage increase during Fiery Brand debuff

### Opportunity Cost

Every GCD spent on ability X is a GCD not spent on ability Y.

```
opportunity_cost(X) = DPGCD(next_best_alternative) - DPGCD(X)
```

If opportunity_cost > 0, ability X should not be cast. An ability is worth casting only when its effective DPGCD exceeds every available alternative.

For abilities with secondary effects (healing, fragments, Fury generation), convert those to damage-equivalent value:

```
effective_DPGCD(X) = direct_DPGCD(X) + fury_generated * fury_to_damage_rate + fragments * fragment_to_damage_rate
```

Where `fury_to_damage_rate = best_spender_DPGCD / best_spender_fury_cost`.

---

## 3. Cooldown Optimization

### Waste Analysis

Every second a cooldown sits ready but unused is lost DPS.

```
waste_dps = ability_total_damage / cooldown_duration * seconds_wasted / cooldown_duration
```

More precisely:

```
casts_lost_per_fight = floor(seconds_wasted / cooldown)
damage_lost = casts_lost_per_fight * damage_per_cast
```

Read cooldown from `cooldown` (simple) or `charges.cooldown` (charge-based) fields in spells.json.

### Alignment Windows

When two cooldowns are active simultaneously, their damage modifiers multiply. The value of alignment:

```
aligned_value = base_damage * mod_A * mod_B
unaligned_value = base_damage * mod_A + base_damage * mod_B  (across separate windows)
alignment_gain = aligned_value - unaligned_value = base_damage * mod_A * mod_B - base_damage * (mod_A + mod_B)
```

This simplifies to: alignment is worth `base_damage * mod_A * mod_B` extra damage, which is positive when both mods > 0. Larger modifiers benefit more from alignment.

### Fractional Cooldown Math

Over a fight of duration T with cooldown C:

```
max_casts = 1 + floor((T - cast_time) / C)
```

For charge-based abilities (Fracture: `charges.count: 2, charges.cooldown: 4.5`):

```
max_casts = charges + floor((T - initial_gcd) / recharge_time)
```

### Holding Cost

DPS lost per second of holding a cooldown:

```
holding_cost_per_sec = damage_per_cast / cooldown^2
```

This derives from: holding C seconds delays all future casts by C seconds, losing approximately one cast over (cooldown / C) cycles. Only hold if the alignment gain exceeds holding_cost \* hold_duration.

### SimC Cooldown Mechanics

**`sync` modifier:** Forces an action to wait until another action is also ready. Useful for aligning cooldowns without complex conditions:

```
actions+=/the_hunt,sync=fiery_brand
```

**`cooldown_react`:** Returns 1 only if the cooldown has elapsed AND sufficient reaction time has passed (default 0.5s). Prevents unrealistic instant reactions to cooldown availability.

**Charge-based cooldowns:** Use `cooldown.X.charges_fractional` for partial charge tracking and `cooldown.X.full_recharge_time` for time until all charges are ready. For Fracture (2 charges, 4.5s recharge):

```
# Cast if we'd cap charges before next GCD
actions+=/fracture,if=cooldown.fracture.charges_fractional>=1.8
```

**Multi-variable hold patterns:** The reference APL uses variables to coordinate hold decisions across multiple cooldowns. Pattern from `reference/vengeance-apl.simc`:

```
variable,name=hold_soul_carver,value=cooldown.fiery_brand.remains<soul_carver_cd*0.3
actions+=/soul_carver,if=!variable.hold_soul_carver&soul_fragments<=2
```

This lets you centralize hold logic in a variable, then reference it from multiple action lines. See `reference/wiki/action-lists.md` (APL Variables section) for variable operations.

---

## 4. Buff/Debuff Maintenance

### Uptime Modeling

For buffs/debuffs with known duration and cooldown:

```
theoretical_uptime = duration / cooldown
```

In interactions.json, some entries include `theoreticalUptime` directly (e.g., Immolation Aura interactions show `theoreticalUptime: 1` for permanent-uptime buffs).

For abilities where uptime < 1, the effective DPS contribution of a buff is:

```
effective_modifier = (modifier_value * uptime) + (1 * (1 - uptime))
```

### Pandemic Windows

Refreshing a buff/debuff before it expires extends the duration up to 130% of base. The pandemic window is the final 30% of the duration.

```
pandemic_window = duration * 0.3
safe_refresh_time = duration - pandemic_window = duration * 0.7
```

For Fiery Brand debuff (207744, `duration: 12`):

- Pandemic window: last 3.6 seconds
- Refresh after 8.4 seconds of the debuff running

Refreshing outside the pandemic window wastes the remaining duration. Refreshing too late leaves a gap.

### Travel Time Compensation for Sigils

Sigils have a placement delay (typically 2 seconds for ground-targeted sigils). Account for this when modeling uptime:

```
effective_gap = cooldown - duration + travel_time
effective_uptime = duration / (cooldown + travel_time)
```

With Quickened Sigils or Concentrated Sigils, the delay changes. Check talent modifications in interactions.json.

### Buff Cascade Chains

Some buffs enable or amplify other effects, creating chains:

```
Fiery Brand (cast) -> Fiery Brand debuff (207744, 12s duration)
  -> Fiery Demise (talent): +15/30% damage to branded target (multiplicative)
  -> All Fire damage abilities benefit during this window
  -> Optimal: stack as many Fire damage GCDs into the 12s window as possible
```

Model cascade value as:

```
cascade_value = sum(ability_damage * modifier_from_chain) for each ability cast during window
              - sum(ability_damage) for the same abilities cast without the chain
```

---

## 5. AoE Scaling Analysis

### Target-Count Breakpoints

For each ability, look up the `aoe` field in spells.json: `{radius, maxTargets, reducedAoe}`.

Compare single-target DPGCD to AoE DPGCD:

```
AoE_DPGCD(N) = single_hit_damage * min(N, maxTargets) * aoe_reduction_factor(N)
```

Where `reducedAoe` indicates reduced damage beyond a threshold (typically sqrt scaling or explicit cap).

Spirit Bomb (247454): "Deals reduced damage beyond 8 targets" (`effects[2].details.baseValue: 8`). Below 8 targets, damage scales linearly with fragments consumed (each fragment hits all targets).

### Priority Shifts by Target Count

Build a DPGCD table per ability at each target count:

| Ability              | 1T        | 2T       | 3T        | 5T        | 8T       |
| -------------------- | --------- | -------- | --------- | --------- | -------- |
| Fracture             | coeff\*AP | same     | same      | same      | same     |
| Spirit Bomb (5 frag) | 1.825\*AP | 3.65\*AP | 5.475\*AP | 9.125\*AP | 14.6\*AP |
| Soul Cleave          | X\*AP     | ~2X\*AP  | ...       | ...       | ...      |

The crossover point where AoE abilities surpass ST abilities defines target-count breakpoints for APL `active_enemies>=N` conditions.

### Funnel vs Spread Damage

- **Spread:** Damage is split evenly across targets (e.g., Spirit Bomb hits all targets equally).
- **Funnel:** Damage concentrates on priority target while cleaving.
- **Quadratic scaling:** When both fragment generation AND fragment consumption scale with targets.

### Quadratic Soul Fragment Scaling

With the Fallout talent, Immolation Aura ticks have a chance to generate fragments from each target hit. More targets = more fragment procs = more Spirit Bombs = more AoE damage.

```
fragments_from_fallout = targets * ticks * proc_chance
spirit_bombs_possible = fragments_from_fallout / fragments_per_bomb
total_aoe_damage = spirit_bombs_possible * damage_per_bomb * targets
```

This creates quadratic scaling: damage grows with targets^2 (linear fragment generation \* linear bomb damage per target).

---

## 6. Talent Interaction Analysis

### Modifier Stacking Calculations

In interactions.json, each interaction has `magnitude.stacking` indicating how it combines:

- `"multiplicative"`: `total = product of (1 + value/100) for each modifier`
- `"additive"`: `total = 1 + sum(value/100) for each modifier`

Example — modifiers on Spirit Bomb (247455) from interactions.json:

1. Fiery Demise: +30% multiplicative (during Fiery Brand)
2. Fiery Brand debuff (207744): damage taken modifier on target
3. Mastery: Demonic Presence: variable based on mastery rating

```
total_modifier = (1 + fiery_demise) * (1 + fiery_brand_debuff) * (1 + mastery)
```

### Synergy Cluster Discovery

Query interactions.json `bySpell` lookups to find all talents that modify a given spell. Talents that modify the same high-value spell form a synergy cluster.

```javascript
// Pseudo-query: find all modifiers for Spirit Bomb
interactions.filter(
  (i) => i.target.name === "Spirit Bomb" && i.type === "damage_modifier",
);
```

Clusters to investigate:

- **Spirit Bomb cluster:** Fiery Demise + Fiery Brand + Vulnerability + Frailty interactions
- **Immolation Aura cluster:** Fallout + Charred Flesh + Burning Alive
- **Sigil cluster:** Concentrated Sigils + Quickened Sigils + Sigil-related talents

### Build-APL Co-optimization

Talent builds and APL logic are interdependent. A talent that buffs Spirit Bomb only matters if the APL actually casts Spirit Bomb frequently enough to benefit. Steps:

1. Identify which talents are taken in the build.
2. Filter interactions.json to only those whose source is a taken talent.
3. Weight abilities by their modified DPGCD under the active talent set.
4. Order the APL by weighted DPGCD, accounting for resource constraints.

---

## 7. Proc/RPPM Analysis

### Expected Proc Rates

In interactions.json, proc-based interactions have `procInfo`:

```json
"procInfo": {
  "procChance": 100   // percent chance per trigger event
}
```

In spells.json, look for `procChance` (percent per event) or `realPPM` (procs per minute, haste-adjusted).

For RPPM:

```
expected_procs_per_minute = RPPM * (1 + haste_percent/100)
avg_time_between_procs = 60 / expected_procs_per_minute
```

For flat proc chance:

```
expected_procs = trigger_events * (procChance / 100)
```

### Proc DPS Value

```
proc_dps = (proc_damage * expected_procs_per_minute) / 60
```

For buff procs:

```
proc_uptime = min(1, proc_duration * expected_procs_per_minute / 60)
proc_dps_value = total_buffed_damage * modifier * proc_uptime
```

### ICD Floors

`internalCooldown` in spells.json caps proc frequency regardless of trigger rate:

```
max_procs_per_minute = 60 / max(icd, 60 / (trigger_rate * proc_chance))
```

---

## 8. Off-GCD Weaving and Free Actions

### Identifying Off-GCD Abilities

Filter spells.json for `gcd: 0`:

- Demon Spikes (defensive, off-GCD)
- Metamorphosis (off-GCD, `gcd: 0`)
- Infernal Strike (off-GCD, movement + damage)
- Vengeful Retreat (off-GCD)

These abilities can be cast between GCDs without delaying the next on-GCD ability.

### Weaving Without DPS Loss

Off-GCD abilities are "free" in terms of GCD budget but still have animation time. In SimC, off-GCD actions are woven automatically if placed in the APL. Place them before on-GCD abilities in the priority list so they fire during GCD dead time.

APL pattern:

```
actions+=/demon_spikes,if=charges>=1&!buff.demon_spikes.up
actions+=/infernal_strike,if=!talent.spirit_bomb|soul_fragments<=3
actions+=/fracture,if=...  # on-GCD follows
```

### Movement Abilities as Free Damage

Infernal Strike deals Fire damage on landing (check `apCoefficient` on the damage effect). Since it is off-GCD and also a movement ability, it provides:

```
free_dps = infernal_strike_damage / infernal_strike_cooldown
```

This damage costs zero GCDs. It should always be used on cooldown in pure DPS optimization (subject to positional constraints in actual gameplay).

### SimC Off-GCD Modifiers

**`use_off_gcd=1`:** Explicitly marks an action for off-GCD execution. SimC will attempt to weave it between GCD-locked actions. Required for actions that SimC doesn't automatically recognize as off-GCD:

```
actions+=/demon_spikes,use_off_gcd=1,if=charges>=1&!buff.demon_spikes.up
```

**`use_while_casting=1`:** Allows an action during a cast or channel. Useful for off-GCD abilities during Fel Devastation's channel:

```
actions+=/metamorphosis,use_while_casting=1,if=action.fel_devastation.channeling
```

**GCD lag mechanics:** In SimC, there is a small delay between when an off-GCD action can fire and when the sim checks for it. The sim checks at GCD boundaries and at certain event points. Placing off-GCD actions earlier in the priority list ensures they're evaluated first during these checks. See `reference/wiki/action-lists.md` (Non-Standard Timing section).

---

## 9. Systematic Non-Obvious Insight Discovery

### Inverse Optimization

Deliberately violate an APL rule and measure the DPS delta. If removing a condition causes less DPS loss than expected, the condition may be over-constrained. If it causes more, the condition is load-bearing.

```
baseline_dps = sim(original_apl)
modified_dps = sim(apl_with_rule_removed)
rule_value = baseline_dps - modified_dps
```

Run this for each conditional in the APL to build a "condition value map."

### Correlation Mining from Sim Data

After running sims, analyze:

- Ability cast counts vs DPS
- Resource waste rates vs DPS
- Buff uptimes vs DPS

Strong correlations reveal which factors most influence the outcome.

### Sensitivity Analysis

Vary numeric thresholds in APL conditions and measure DPS response:

```
# Test fury threshold for Spirit Bomb
for threshold in [30, 40, 50, 60, 70, 80]:
    sim(apl with: spirit_bomb,if=fury>={threshold}&soul_fragments>=4)
```

Plot DPS vs threshold to find optimal breakpoints and flat regions (where exact value does not matter).

### Cross-Scenario Divergence Detection

Run the same APL against Patchwerk at different target counts:

- Patchwerk 1T (pure single target)
- Patchwerk 5T (sustained cleave)
- Patchwerk 10T (heavy AoE)

Abilities whose rank changes dramatically between target counts need target-count-specific APL branches (`active_enemies>=N`). Key breakpoints to look for: when Spirit Bomb overtakes Soul Cleave, when Immolation Aura + Fallout fragment generation becomes dominant, and when GCD budget shifts from builder-heavy to spender-heavy.

### Execute Phase Detection

Some APL conditions should change as the target approaches death. Use `target.health.pct` and `target.time_to_die` to detect execute phases:

```
# More aggressive cooldown usage when fight is ending
actions+=/the_hunt,if=target.time_to_die<15
# Dump resources instead of pooling
actions+=/soul_cleave,if=target.time_to_die<5
```

Test APL variants with `target.time_to_die` thresholds via sensitivity analysis (Section 9) to find where execute-phase logic adds value.

### Consumable Timing

Potions and on-use trinkets have a single use (or limited uses) per fight. Optimal timing depends on cooldown alignment:

```
actions+=/potion,if=buff.metamorphosis.up|target.time_to_die<30
```

Test potion timing against different fight durations using profilesets. The optimal window shifts based on whether major cooldowns align at the start or mid-fight.

### Second-Order Effect Chains

Trace indirect value chains that do not appear in direct DPGCD calculations:

```
More Soul Fragments (from Fracture/Fallout)
  -> Bigger Spirit Bombs (more fragments consumed)
    -> More Frailty uptime (Spirit Bomb applies Frailty)
      -> More self-healing (Frailty heals for 8% of damage dealt)
        -> Fewer Demon Spikes needed for survival
          -> More offensive GCDs available (Demon Spikes is off-GCD, but fewer needed = less resource spent on defense)
            -> Higher sustained DPS
```

These chains are invisible in single-ability analysis. Model them by tracing `interactions.json` chains: find interactions where the target of one interaction is the source of another.

### Timing Micro-optimization

GCDs are quantized at 1.5s / haste. Buff durations and cooldowns are continuous. This mismatch creates optimization opportunities:

```
GCDs_in_buff_window = floor(buff_duration / effective_gcd)
```

If a buff lasts 12s and GCD is 1.25s, you get exactly 9 GCDs (9 _ 1.25 = 11.25s, fitting within 12s). The remaining 0.75s is wasted. Pandemic refresh at 8.4s (12 _ 0.7) gives you another potential 9 GCDs in the extended window.

### Diminishing Returns Identification

Some modifiers have diminishing returns when stacked. Check if multiple interactions targeting the same spell use `stacking: "additive"` — these sum linearly and each additional point is worth less relative to total. Multiplicative stacking has increasing marginal returns.

### Talent-Combination Search Space

With N binary talent choices, there are 2^N possible builds. Use profilesets in SimC to explore:

```
profileset."build_A"+=talents=...
profileset."build_B"+=talents=...
```

Focus on talent clusters identified in Section 6. For a cluster of 5 interdependent talents, test all 32 combinations rather than evaluating each talent independently.

---

## 10. Mathematical Frameworks

### Expected Value per GCD

```
E[damage_per_GCD] = sum over all abilities:
  P(ability_is_castable) * P(ability_is_highest_priority) * damage(ability)
```

In practice, approximate by the deterministic priority ordering weighted by castability (resource available, not on cooldown).

### Resource Equilibrium Equations

For Fury:

```
Let G = total Fury generation per GCD cycle
Let S = Fury cost of chosen spender
Let R = ratio of builder GCDs to spender GCDs

Equilibrium: G * R_builders = S * R_spenders
Where: R_builders + R_spenders + R_other = 1 (GCD budget)
```

For Fracture (25 Fury, 1 GCD) -> Spirit Bomb (40 Fury, 1 GCD):

```
25 * R_fracture = 40 * R_spiritbomb
R_fracture / R_spiritbomb = 40/25 = 1.6
```

So you need 1.6 Fracture GCDs per Spirit Bomb GCD (ignoring other Fury sources). With other generation (Immolation Aura, Felblade), this ratio decreases.

### Uptime Under GCD Constraints

For a buff that must be maintained via a GCD-costing ability:

```
uptime_cost = GCD / cooldown  (fraction of GCD budget consumed)
effective_uptime = min(1, duration / cooldown)
```

If maintaining the buff costs too many GCDs, net DPS may decrease despite the buff's value.

```
net_value = (buffed_dps - unbuffed_dps) * uptime - opportunity_cost * uptime_cost * GCDs_per_minute
```

### AoE Damage Scaling Functions

**Linear scaling (capped):**

```
damage(N) = single_target_damage * min(N, maxTargets)
```

**Square-root reduced scaling (beyond cap):**

```
damage(N) = single_target_damage * (cap + sqrt(N - cap))  [for N > cap]
```

**Quadratic (fragment-dependent):**

```
damage(N) = fragment_generation(N) * damage_per_fragment * N
           = (base_frags + N * fallout_rate) * coeff * AP * N
```

---

## 11. Data File Reference

### spells.json

Each entry is a spell object. Key fields:

| Field                             | Type    | Description                                                              |
| --------------------------------- | ------- | ------------------------------------------------------------------------ |
| `id`                              | number  | Spell ID                                                                 |
| `name`                            | string  | Spell name                                                               |
| `school`                          | string  | Damage school (Physical, Fire, Chromatic, etc.)                          |
| `passive`                         | boolean | True if passive/aura                                                     |
| `resource`                        | object  | `{cost, type, typeId, spellId}` — Fury cost                              |
| `resourceFlow`                    | object  | `{costs: [{amount, resourceType}], generates: [{amount, resourceType}]}` |
| `gcd`                             | number  | 0 = off-GCD, 1.5 = standard, 0.5 = reduced                               |
| `cooldown`                        | number  | Seconds (simple cooldown)                                                |
| `charges`                         | object  | `{count, cooldown}` for charge-based abilities                           |
| `duration`                        | number  | Buff/debuff duration in seconds                                          |
| `effects[]`                       | array   | Each effect has `index`, `effectId`, `type`, `details`                   |
| `effects[].details.apCoefficient` | number  | Attack Power coefficient for damage calculation                          |
| `effects[].details.baseValue`     | number  | Base value (fragment count, dummy data, etc.)                            |
| `effects[].details.delta`         | number  | Damage variance (e.g., 0.05 = +/-5%)                                     |
| `effects[].details.radius`        | string  | AoE radius (e.g., "0 - 8 yards")                                         |
| `aoe`                             | object  | `{radius, maxTargets, reducedAoe}` when present                          |
| `hasteScaling`                    | object  | `{gcd: true/false}` — whether GCD scales with haste                      |
| `procChance`                      | number  | Percent chance to proc (per trigger event)                               |
| `realPPM`                         | number  | Real procs per minute (haste-scaled)                                     |
| `internalCooldown`                | number  | Minimum seconds between procs                                            |
| `description`                     | string  | Tooltip text with template variables                                     |
| `resolvedDescription`             | string  | Tooltip with variables resolved to values                                |
| `affectingSpells[]`               | array   | Spells that modify this spell, with affected effect indices              |
| `triggeredBy[]`                   | array   | Spells that trigger this spell                                           |
| `schoolMask`                      | number  | Bitmask for damage school                                                |

### interactions.json

Top-level structure:

```json
{
  "interactions": [ ... ],   // flat array of all interactions
  "bySpell": { ... },        // lookup by target spell ID
  "byTalent": { ... }        // lookup by source talent name
}
```

Each interaction object:

| Field                | Type   | Description                                                                |
| -------------------- | ------ | -------------------------------------------------------------------------- |
| `source`             | object | `{id, name, isTalent, tree, heroSpec}`                                     |
| `target`             | object | `{id, name}` — the spell being modified                                    |
| `type`               | string | `"damage_modifier"`, `"proc_trigger"`, `"resource_modifier"`, etc.         |
| `effects[]`          | array  | Which effect indices on the target are modified                            |
| `discoveryMethod`    | string | `"spell_data"`, `"effect_scan"`, `"cpp_source"`                            |
| `confidence`         | string | `"high"`, `"medium"`, `"low"`                                              |
| `magnitude`          | object | `{value, unit, stacking, perRank, maxRank}`                                |
| `magnitude.value`    | number | Modifier amount (e.g., 15 for 15%)                                         |
| `magnitude.unit`     | string | `"percent"`, `"flat"`, `"sp_coefficient"`                                  |
| `magnitude.stacking` | string | `"multiplicative"` or `"additive"`                                         |
| `schoolTarget[]`     | array  | Schools affected (e.g., `["Fire"]`)                                        |
| `procInfo`           | object | `{procChance}` — proc details when applicable                              |
| `theoreticalUptime`  | number | 0-1, expected uptime fraction                                              |
| `application`        | string | `"buff_on_player"`, `"debuff_on_target"`                                   |
| `categories[]`       | array  | `["offensive"]`, `["defensive"]`, `["offensive", "defensive"]`             |
| `effectDetails[]`    | array  | Detailed effect breakdown with type, baseValue, affectedSpells, schoolMask |

### talents.json

Top-level structure:

```json
{
  "class": { "name": "Demon Hunter", "talents": [...] },
  "spec": { "name": "Vengeance", "talents": [...] },
  "hero": {
    "Aldrachi Reaver": { "subtreeId": 35, "talents": [...] },
    "Annihilator": { "subtreeId": 124, "talents": [...] }
  }
}
```

Each talent object:

| Field          | Type   | Description                                                      |
| -------------- | ------ | ---------------------------------------------------------------- |
| `name`         | string | Talent name                                                      |
| `spellId`      | number | Associated spell ID (cross-ref with spells.json)                 |
| `nodeId`       | number | Talent tree node ID                                              |
| `posX`, `posY` | number | Position in talent tree grid                                     |
| `maxRank`      | number | Maximum talent ranks                                             |
| `type`         | string | `"active_ability"`, `"off_gcd_ability"`, `"passive"`, `"choice"` |
| `cooldown`     | number | Cooldown if applicable                                           |
| `gcd`          | number | GCD if applicable                                                |
| `charges`      | object | `{count, cooldown}` if charge-based                              |
| `description`  | string | Talent tooltip                                                   |
| `affectedBy[]` | array  | Talents/spells that modify this talent                           |

---

## 12. VDH Worked Examples Appendix

### Example A: Spirit Bomb DPGCD Calculation

**Base damage (5 fragments, single target):**

```
Spirit Bomb damage spell: 247455
apCoefficient: 0.365 (per fragment)
fragments: 5

raw_damage = AP * 0.365 * 5 = AP * 1.825
gcd = 1.5 / haste_factor

At 100k AP, 20% haste:
raw_damage = 100000 * 1.825 = 182,500
effective_gcd = 1.5 / 1.2 = 1.25s
DPGCD = 182,500 (per GCD)
DPS_contribution = 182,500 / 1.25 = 146,000 DPS
```

**With Fiery Demise (2/2) during Fiery Brand:**

```
Fiery Demise: +30% multiplicative (magnitude.value: 15, perRank: true, maxRank: 2)
Fiery Brand debuff: additional damage taken modifier

modified_damage = 182,500 * 1.30 = 237,250
modified_DPS = 237,250 / 1.25 = 189,800 DPS
```

**Frailty secondary value:**

Spirit Bomb applies Frailty (247456): "heal for 8% of damage dealt to them" for 6 seconds. This healing offsets defensive GCD requirements.

### Example B: Fury Economy Under Fracture -> Spirit Bomb Cycle

```
Fracture:
  Fury generated: 25 per cast
  GCD cost: 1.25s (at 20% haste)
  Charges: 2, recharge: 4.5s / 1.2 = 3.75s

Spirit Bomb:
  Fury cost: 40
  GCD cost: 1.25s
  Requires: 4-5 Soul Fragments

Cycle: 2x Fracture -> 1x Spirit Bomb
  Fury generated: 2 * 25 = 50
  Fury spent: 40
  Net Fury: +10 (surplus)
  Fragments generated: 2 * 2 = 4 (minimum for Spirit Bomb)
  GCDs consumed: 3
  Cycle time: 3 * 1.25 = 3.75s

Sustainable rate: 50 Fury gen / 3.75s = 13.33 Fury/sec generation
  vs 40 Fury / 3.75s = 10.67 Fury/sec spending
  Surplus: 2.67 Fury/sec (available for Soul Cleave or accumulation)
```

With additional Fury from Immolation Aura and Felblade, the surplus grows, allowing more frequent spender casts or weaving in Soul Cleave for healing.

### Example C: Fiery Demise Alignment Window Value

```
Fiery Brand:
  Cooldown: 60s (charges.cooldown on 204021)
  Debuff duration: 12s (duration on 207744)
  Charges: 1 base

Fiery Demise (2/2): +30% damage to branded target

Window: 12 seconds of +30% damage
GCDs in window: floor(12 / 1.25) = 9 GCDs (at 20% haste)

Value of alignment = sum of (ability_damage * 0.30) for all 9 GCDs
If average DPGCD = 150,000:
  alignment_value = 9 * 150,000 * 0.30 = 405,000 bonus damage per window
  per-minute value = 405,000 / 60 = 6,750 DPS

This is the DPS value of perfectly aligning all GCDs within the Fiery Brand window.
Misalignment (casting low-value abilities during the window) wastes this.
```

### Example D: Soul Fragment Quadratic AoE Scaling

```
Fallout talent: Immolation Aura ticks have a chance to shatter fragments from each target.

Assume Fallout proc rate: P per tick per target
Immolation Aura ticks: T over duration
Targets: N

Fragments from Fallout = T * N * P
Base fragments from Fracture = 2 per Fracture (fixed, not target-dependent)

Spirit Bomb damage per cast = 0.365 * AP * fragments_consumed * N (hits all targets)

Total cycle damage:
  fragments = 2 * fracture_casts + T * N * P
  spirit_bombs = fragments / 5
  damage = spirit_bombs * 0.365 * AP * 5 * N
         = fragments * 0.365 * AP * N
         = (2F + T*N*P) * 0.365 * AP * N

The T*N*P*N term gives quadratic scaling in N (targets).

At 5 targets with P=0.3, T=6 ticks:
  fallout_fragments = 6 * 5 * 0.3 = 9 bonus fragments per Immolation Aura
  Combined with 2 Fractures (4 fragments): 13 fragments per cycle
  Spirit Bombs possible: 2.6 (13/5) per cycle
  Each hits 5 targets at 0.365 * AP per fragment per target
```

### Example E: GCD Budget Allocation (1 minute)

```
Base GCD: 1.5s, 20% haste -> effective GCD: 1.25s
Total GCDs per minute: 60 / 1.25 = 48

Allocation:
  Fracture:       ~16 casts (2 charges, 3.75s recharge -> 16/min)
  Spirit Bomb:    ~8 casts (every 2 Fractures, limited by fragments)
  Sigil of Flame: ~2 casts (30s CD)
  Felblade:       ~1 cast (15s CD, 0.5s GCD -> counts as ~0.4 of a full GCD each)
  Fel Devastation: ~1 cast (60s CD, channel)
  Soul Cleave:    ~4 casts (Fury surplus dumps)
  Fiery Brand:    ~1 cast (60s CD)
  Soul Carver:    ~2 casts (30s CD, if talented)
  -------------------------------------------------
  Total:          ~35 on-GCD actions

  Remaining:      ~13 GCDs for fillers, movement, or downtime

Off-GCD (free):
  Demon Spikes:   as needed (charges)
  Infernal Strike: on cooldown (movement + damage)
  Metamorphosis:  1 per 3-4 minutes
```

This budget reveals that the APL has ~13 spare GCDs per minute. These can be filled with additional Soul Cleaves, extra Fracture charges (if pooled), or are lost to movement/mechanics. Minimizing empty GCDs is a primary optimization target.

---

## 13. SimC APL Mechanics Reference

### Action Modifiers

Key modifiers beyond basic `if=` conditions (full reference: `reference/wiki/action-lists.md`):

- **`cycle_targets=1`**: Cycles the action through all available targets. Combine with `target_if=` for smart targeting:

```
actions+=/fiery_brand,cycle_targets=1,target_if=min:dot.fiery_brand.remains,if=!dot.fiery_brand.ticking
```

- **`target_if=min:expr` / `target_if=max:expr`**: Select target with min/max expression value. `target_if=first:expr` selects first target where expression is nonzero.

- **`line_cd=N`**: Forces N seconds between executions of this action, even if it's otherwise ready. Prevents spamming:

```
actions+=/sigil_of_flame,line_cd=8,if=!debuff.sigil_of_flame.up
```

- **`interrupt_if=expr`**: Interrupts a channel when expression is true and GCD has elapsed. For Fel Devastation:

```
actions+=/fel_devastation,interrupt_if=soul_fragments>=4&fury>=40
```

- **`chain=1`**: Re-casts a channeled spell at the beginning of its last tick. `early_chain_if=expr` chains at any tick if expression is true.

- **`sync=action_name`**: Prevents execution unless another action is also ready (see Section 3).

- **`use_off_gcd=1` / `use_while_casting=1`**: Off-GCD timing control (see Section 8).

- **`cancel_if=expr`**: Cancels a channeled action when the expression becomes true, even mid-channel.

- **`wait_until_ready=1`**: Restarts action list scanning if this action is the best choice but isn't ready yet, rather than falling through to lower-priority actions.

### Advanced Expressions

Key expressions for APL conditions (full reference: `reference/wiki/action-list-expressions.md`):

- **`prev_gcd.1.spell_name`**: True if the last GCD action was `spell_name`. The `.1` is the history depth (1 = last, 2 = two ago). Useful for sequencing:

```
actions+=/spirit_bomb,if=prev_gcd.1.fracture&soul_fragments>=4
```

- **`~` / `!~`**: String-in/not-in operators (from SpellQuery). Rarely used in APLs but available.

- **`<?` / `>?`**: Max/min of two values. `a<?b` returns the larger; `a>?b` returns the smaller:

```
# Cap fragment count at 5 for calculations
variable,name=frag_cap,value=soul_fragments<?5
```

- **`%%`**: Modulus operator. Useful for cyclic timing:

```
# Every 3rd GCD action
variable,name=cycle_count,op=add,value=1
actions+=/ability,if=variable.cycle_count%%3=0
```

- **`buff.X.react`**: Stack count of buff X, but only after reaction time has elapsed. More realistic than `buff.X.stack` for proc-based buffs.

- **`action.X.in_flight`**: True if spell X is currently traveling to target. Use `action.X.in_flight_to_target` for current-target-specific check.

- **`cooldown.X.full_recharge_time`**: Time until all charges of X are ready. For charge-based abilities, this is more useful than `cooldown.X.remains` which only tracks the next charge.

### VDH-Specific Expressions

From `reference/wiki/demon-hunters.md`:

- **`soul_fragments`**: Active consumable soul fragments (all types).
- **`soul_fragments.active`**: Same as `soul_fragments`.
- **`soul_fragments.inactive`**: Spawned but not yet consumable (still traveling to player).
- **`soul_fragments.total`**: Active + inactive.
- **`greater_soul_fragments`**: Active consumable Greater soul fragments only.
- **`lesser_soul_fragments`**: Active consumable Lesser soul fragments only.
- **`demon_soul_fragments`**: Active consumable Demon soul fragments only.
- **`apex.N`**: Apex talent rank check where N is the rank number (e.g., `apex.1`, `apex.2`). Use this syntax instead of `talent.apex_name` for apex (pinnacle) talents.

VDH-specific options that affect sim behavior:

- `wounded_quarry_chance_vengeance` (default 0.3): Proc chance for Wounded Quarry fragments.
- `felblade_lockout_from_vengeful_retreat` (default 0.6s): Felblade lockout after Vengeful Retreat.

### APL Variables

Variables store computed values for reuse across conditions. Operations: `set`, `add`, `sub`, `mul`, `div`, `min`, `max`, `setif`, `reset`, `floor`, `ceil`.

```
# Define a variable
variable,name=spirit_bomb_threshold,value=soul_fragments>=4&fury>=40

# Use it
actions+=/spirit_bomb,if=variable.spirit_bomb_threshold

# Conditional set with fallback
variable,name=pool_fury,op=setif,value=1,value_else=0,condition=cooldown.fel_devastation.remains<3
```

`cycling_variable` iterates over all targets to accumulate values:

```
actions+=/variable,name=branded_count,op=reset
actions+=/cycling_variable,name=branded_count,op=add,value=dot.fiery_brand.ticking
```

Full reference: `reference/wiki/action-lists.md` (APL Variables section).

---

## 14. Target Count Considerations

We simulate Patchwerk only, at three target counts: **1T**, **5T**, and **10T**. Each represents a distinct optimization regime.

### Patchwerk 1T (Pure Single Target)

- Full GCD budget on priority target.
- Spirit Bomb value comes from per-fragment coefficient × 5, not from target scaling.
- Cooldown alignment is the primary optimization lever — Fiery Brand + Fiery Demise windows are high value.
- Soul fragment economy is deterministic: Fracture generates fragments at a fixed rate, Fallout contributes nothing.
- Resource pooling for burst windows matters most here.

### Patchwerk 5T (Sustained Cleave)

- Spirit Bomb damage scales linearly with targets (each fragment hits all 5), making it dramatically higher DPGCD than 1T.
- Fallout talent becomes significant: Immolation Aura ticks proc fragments from each target, feeding the quadratic scaling loop (Section 5).
- Fragment economy shifts from deterministic to probabilistic — Fallout proc variance affects Spirit Bomb cadence.
- `active_enemies>=N` breakpoints define when AoE priorities override ST priorities. Key threshold: where Spirit Bomb at 3-4 fragments overtakes waiting for 5.
- Fiery Brand's single-target damage amp is diluted across 5 targets — alignment value decreases relative to raw AoE throughput.

### Patchwerk 10T (Heavy AoE)

- Spirit Bomb hits reduced damage beyond 8 targets (`reducedAoe`), so scaling is sublinear past 8T.
- Fragment generation from Fallout is abundant — the constraint shifts from "enough fragments" to "enough Fury and GCDs to spend them."
- GCD budget becomes the binding constraint. Every on-GCD action competes for limited slots, so abilities with weak per-target scaling get dropped.
- Immolation Aura's passive ticking damage (hitting all targets) becomes a larger share of total damage.
- Soul Cleave's value relative to Spirit Bomb depends on whether you have the fragments and Fury for Spirit Bomb; at 10T with Fallout, you almost always do.

### What to Compare Across Target Counts

When running the same APL at 1T, 5T, and 10T, look for:

1. **Ability rank inversions** — abilities that are high-priority at 1T but low at 5T (or vice versa).
2. **Wasted casts** — abilities being cast at target counts where they're suboptimal.
3. **Fragment waste** — fragments expiring or overflowing at high target counts (check `soul_fragment_expire` and `soul_fragment_overflow` procs in sim output).
4. **Fury waste** — overcapping Fury at high target counts when fragment generation outpaces spending ability.
5. **Missing `active_enemies` conditions** — actions that should have target-count guards but don't.

---

## 15. APL Verification & Debugging

### Combat Logging

Enable `log=1` in the SimC profile to generate a full combat log. This shows every action taken, resource state, buff tracking, and damage events:

```
log=1
iterations=1
```

Use single-iteration logs to trace specific sequences. Look for: ability usage order, resource values at decision points, buff uptimes, and wasted cooldown time.

### APL Export

`save_actions=filename.simc` exports the resolved APL after all variable substitutions and default list generation. Useful for verifying what SimC actually executes vs. what you wrote.

### Variance Analysis

`report_rng=1` adds RNG breakdown to the report — shows how much of the DPS variance comes from proc luck vs. other factors. Combine with higher iteration counts for statistical confidence.

For formal A/B testing between APL variants, use `target_error=0.1` (or lower) to ensure results are statistically meaningful. See `reference/wiki/statistical-behaviour.md`.

### Profile Sets for A/B Testing

Profile sets run multiple configurations in a single sim, sharing the RNG seed for paired comparison:

```
profileset."baseline"+=
profileset."variant_A"+=actions=...modified_apl...
profileset."fury_threshold_50"+=actions.single_target+=/spirit_bomb,if=fury>=50&soul_fragments>=4
```

Output ranks all profilesets by DPS with confidence intervals. This is the primary tool for comparing APL changes. See `reference/wiki/profile-sets.md`.

### Spell Data Overrides

Test hypothetical tuning changes without modifying source code:

```
# What if Spirit Bomb's coefficient was 10% higher?
override.spell_data=247455,4,0.4015  # effect 4, new AP coefficient
```

Useful for sensitivity analysis: "How much would DPS change if this ability were buffed/nerfed?" See `reference/wiki/spell-data-overrides.md`.
